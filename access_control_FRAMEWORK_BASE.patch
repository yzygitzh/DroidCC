From 73eb7fc691d87360e9c4e6613042c6a1dd1134ca Mon Sep 17 00:00:00 2001
From: Ziyue Yang <yzylivezh@hotmail.com>
Date: Wed, 12 Apr 2017 15:59:37 +0800
Subject: [PATCH] access control patch

---
 Android.mk                                         |   1 +
 api/current.txt                                    |  25 +++
 api/system-current.txt                             |  25 +++
 core/java/android/app/DroidCCManager.java          |  63 ++++++
 core/java/android/app/SystemServiceRegistry.java   |  10 +
 core/java/android/content/Context.java             |   2 +
 core/java/android/os/IDroidCCService.aidl          |  15 ++
 core/java/android/view/View.java                   |  64 ++++++
 core/java/android/view/ViewGroup.java              |  30 ++-
 core/java/android/view/ViewRootImpl.java           |  13 ++
 .../java/com/android/server/DroidCCService.java    | 214 +++++++++++++++++++++
 .../android/server/am/ActivityManagerService.java  |  10 +
 .../android/server/pm/PackageManagerService.java   |  35 +++-
 services/java/com/android/server/SystemServer.java |   8 +
 14 files changed, 496 insertions(+), 19 deletions(-)
 create mode 100644 core/java/android/app/DroidCCManager.java
 create mode 100644 core/java/android/os/IDroidCCService.aidl
 create mode 100644 services/core/java/com/android/server/DroidCCService.java

diff --git a/Android.mk b/Android.mk
index 99e0c46..9a73dd4 100644
--- a/Android.mk
+++ b/Android.mk
@@ -206,6 +206,7 @@ LOCAL_SRC_FILES += \
 	core/java/android/os/IBatteryPropertiesListener.aidl \
 	core/java/android/os/IBatteryPropertiesRegistrar.aidl \
 	core/java/android/os/ICancellationSignal.aidl \
+	core/java/android/os/IDroidCCService.aidl \
 	core/java/android/os/IDeviceIdleController.aidl \
 	core/java/android/os/IMessenger.aidl \
 	core/java/android/os/INetworkActivityListener.aidl \
diff --git a/api/current.txt b/api/current.txt
index d7fdb2d..bf4cfb6 100644
--- a/api/current.txt
+++ b/api/current.txt
@@ -4187,6 +4187,14 @@ package android.app {
     field public static final int VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION = 3; // 0x3
   }
 
+  public class DroidCCManager {
+    ctor public DroidCCManager(android.content.Context, android.os.IDroidCCService);
+    method public boolean checkPermission(java.lang.String, int);
+    method public void clearViewPid(int);
+    method public void setViewBack(java.util.List<java.lang.String>, java.util.List<java.lang.String>);
+    method public void setViewTouch(java.util.List<java.lang.String>, java.util.List<java.lang.String>);
+  }
+
   public class ExpandableListActivity extends android.app.Activity implements android.widget.ExpandableListView.OnChildClickListener android.widget.ExpandableListView.OnGroupCollapseListener android.widget.ExpandableListView.OnGroupExpandListener android.view.View.OnCreateContextMenuListener {
     ctor public ExpandableListActivity();
     method public android.widget.ExpandableListAdapter getExpandableListAdapter();
@@ -7745,6 +7753,7 @@ package android.content {
     field public static final java.lang.String DEVICE_POLICY_SERVICE = "device_policy";
     field public static final java.lang.String DISPLAY_SERVICE = "display";
     field public static final java.lang.String DOWNLOAD_SERVICE = "download";
+    field public static final java.lang.String DROIDCC_SERVICE = "droid_cc";
     field public static final java.lang.String DROPBOX_SERVICE = "dropbox";
     field public static final java.lang.String FINGERPRINT_SERVICE = "fingerprint";
     field public static final java.lang.String INPUT_METHOD_SERVICE = "input_method";
@@ -23084,6 +23093,20 @@ package android.os {
     method public abstract void binderDied();
   }
 
+  public abstract interface IDroidCCService implements android.os.IInterface {
+    method public abstract boolean checkPermission(java.lang.String, int) throws android.os.RemoteException;
+    method public abstract void clearViewPid(int) throws android.os.RemoteException;
+    method public abstract void setViewBack(java.util.List<java.lang.String>, java.util.List<java.lang.String>) throws android.os.RemoteException;
+    method public abstract void setViewTouch(java.util.List<java.lang.String>, java.util.List<java.lang.String>) throws android.os.RemoteException;
+  }
+
+  public static abstract class IDroidCCService.Stub extends android.os.Binder implements android.os.IDroidCCService {
+    ctor public IDroidCCService.Stub();
+    method public android.os.IBinder asBinder();
+    method public static android.os.IDroidCCService asInterface(android.os.IBinder);
+    method public boolean onTransact(int, android.os.Parcel, android.os.Parcel, int) throws android.os.RemoteException;
+  }
+
   public abstract interface IInterface {
     method public abstract android.os.IBinder asBinder();
   }
@@ -36066,6 +36089,7 @@ package android.view {
     method public int getVerticalFadingEdgeLength();
     method public int getVerticalScrollbarPosition();
     method public int getVerticalScrollbarWidth();
+    method public final void getViewHierarchyInfo(java.util.List<java.lang.String>, java.util.List<java.lang.String>);
     method public android.view.ViewTreeObserver getViewTreeObserver();
     method public int getVisibility();
     method public final int getWidth();
@@ -36230,6 +36254,7 @@ package android.view {
     method public void scrollTo(int, int);
     method public void sendAccessibilityEvent(int);
     method public void sendAccessibilityEventUnchecked(android.view.accessibility.AccessibilityEvent);
+    method public final void sendDroidCCViewInfo(java.lang.String);
     method public void setAccessibilityDelegate(android.view.View.AccessibilityDelegate);
     method public void setAccessibilityLiveRegion(int);
     method public void setAccessibilityTraversalAfter(int);
diff --git a/api/system-current.txt b/api/system-current.txt
index 3c88e59..b0f6668 100644
--- a/api/system-current.txt
+++ b/api/system-current.txt
@@ -4304,6 +4304,14 @@ package android.app {
     field public static final int VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION = 3; // 0x3
   }
 
+  public class DroidCCManager {
+    ctor public DroidCCManager(android.content.Context, android.os.IDroidCCService);
+    method public boolean checkPermission(java.lang.String, int);
+    method public void clearViewPid(int);
+    method public void setViewBack(java.util.List<java.lang.String>, java.util.List<java.lang.String>);
+    method public void setViewTouch(java.util.List<java.lang.String>, java.util.List<java.lang.String>);
+  }
+
   public class ExpandableListActivity extends android.app.Activity implements android.widget.ExpandableListView.OnChildClickListener android.widget.ExpandableListView.OnGroupCollapseListener android.widget.ExpandableListView.OnGroupExpandListener android.view.View.OnCreateContextMenuListener {
     ctor public ExpandableListActivity();
     method public android.widget.ExpandableListAdapter getExpandableListAdapter();
@@ -7989,6 +7997,7 @@ package android.content {
     field public static final java.lang.String DEVICE_POLICY_SERVICE = "device_policy";
     field public static final java.lang.String DISPLAY_SERVICE = "display";
     field public static final java.lang.String DOWNLOAD_SERVICE = "download";
+    field public static final java.lang.String DROIDCC_SERVICE = "droid_cc";
     field public static final java.lang.String DROPBOX_SERVICE = "dropbox";
     field public static final java.lang.String FINGERPRINT_SERVICE = "fingerprint";
     field public static final java.lang.String HDMI_CONTROL_SERVICE = "hdmi_control";
@@ -25028,6 +25037,20 @@ package android.os {
     method public abstract void binderDied();
   }
 
+  public abstract interface IDroidCCService implements android.os.IInterface {
+    method public abstract boolean checkPermission(java.lang.String, int) throws android.os.RemoteException;
+    method public abstract void clearViewPid(int) throws android.os.RemoteException;
+    method public abstract void setViewBack(java.util.List<java.lang.String>, java.util.List<java.lang.String>) throws android.os.RemoteException;
+    method public abstract void setViewTouch(java.util.List<java.lang.String>, java.util.List<java.lang.String>) throws android.os.RemoteException;
+  }
+
+  public static abstract class IDroidCCService.Stub extends android.os.Binder implements android.os.IDroidCCService {
+    ctor public IDroidCCService.Stub();
+    method public android.os.IBinder asBinder();
+    method public static android.os.IDroidCCService asInterface(android.os.IBinder);
+    method public boolean onTransact(int, android.os.Parcel, android.os.Parcel, int) throws android.os.RemoteException;
+  }
+
   public abstract interface IInterface {
     method public abstract android.os.IBinder asBinder();
   }
@@ -38358,6 +38381,7 @@ package android.view {
     method public int getVerticalFadingEdgeLength();
     method public int getVerticalScrollbarPosition();
     method public int getVerticalScrollbarWidth();
+    method public final void getViewHierarchyInfo(java.util.List<java.lang.String>, java.util.List<java.lang.String>);
     method public android.view.ViewTreeObserver getViewTreeObserver();
     method public int getVisibility();
     method public final int getWidth();
@@ -38522,6 +38546,7 @@ package android.view {
     method public void scrollTo(int, int);
     method public void sendAccessibilityEvent(int);
     method public void sendAccessibilityEventUnchecked(android.view.accessibility.AccessibilityEvent);
+    method public final void sendDroidCCViewInfo(java.lang.String);
     method public void setAccessibilityDelegate(android.view.View.AccessibilityDelegate);
     method public void setAccessibilityLiveRegion(int);
     method public void setAccessibilityTraversalAfter(int);
diff --git a/core/java/android/app/DroidCCManager.java b/core/java/android/app/DroidCCManager.java
new file mode 100644
index 0000000..498f62d
--- /dev/null
+++ b/core/java/android/app/DroidCCManager.java
@@ -0,0 +1,63 @@
+package android.app;
+
+import android.annotation.SdkConstant;
+import android.annotation.SystemApi;
+import android.content.Context;
+import android.content.Intent;
+import android.os.Build;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.os.RemoteException;
+import android.os.IDroidCCService;
+import android.util.Log;
+import android.view.View;
+
+import java.util.List;
+import java.util.Map;
+
+public class DroidCCManager {
+    IDroidCCService mService;
+    Context mContext;
+
+    public DroidCCManager(Context ctx, IDroidCCService service) {
+        mService = service;
+        mContext = ctx;
+    }
+
+    public void setViewTouch(List<String> idxList, List<String> viewStrList) {
+        try {
+            mService.setViewTouch(idxList, viewStrList);
+        } catch (Exception e) {
+            Log.e("DroidCCManager", e.toString());
+            e.printStackTrace();
+        }
+    }
+
+    public void setViewBack(List<String> idxList, List<String> viewStrList) {
+        try {
+            mService.setViewBack(idxList, viewStrList);
+        } catch (Exception e) {
+            Log.e("DroidCCManager", e.toString());
+            e.printStackTrace();
+        }
+    }
+
+    public boolean checkPermission(String permission, int uid){
+        try {
+            return mService.checkPermission(permission, uid);
+        } catch(Exception e) {
+            Log.e("DroidCCManager", e.toString());
+            e.printStackTrace();
+        }
+        return true;
+    }
+
+    public void clearViewPid(int pid) {
+        try {
+            mService.clearViewPid(pid);
+        } catch(Exception e) {
+            Log.e("DroidCCManager", e.toString());
+            e.printStackTrace();
+        }
+    }
+}
\ No newline at end of file
diff --git a/core/java/android/app/SystemServiceRegistry.java b/core/java/android/app/SystemServiceRegistry.java
index 3d264c6..16e36c6 100644
--- a/core/java/android/app/SystemServiceRegistry.java
+++ b/core/java/android/app/SystemServiceRegistry.java
@@ -86,6 +86,7 @@ import android.nfc.NfcManager;
 import android.os.BatteryManager;
 import android.os.DropBoxManager;
 import android.os.IBinder;
+import android.os.IDroidCCService;
 import android.os.IPowerManager;
 import android.os.IUserManager;
 import android.os.PowerManager;
@@ -704,6 +705,15 @@ final class SystemServiceRegistry {
             public RadioManager createService(ContextImpl ctx) {
                 return new RadioManager(ctx);
             }});
+
+        registerService(Context.DROIDCC_SERVICE, DroidCCManager.class,
+            new CachedServiceFetcher<DroidCCManager>() {
+            @Override
+            public DroidCCManager createService(ContextImpl ctx) {
+                IBinder b = ServiceManager.getService(Context.DROIDCC_SERVICE);
+                IDroidCCService service = IDroidCCService.Stub.asInterface(b);
+                return new DroidCCManager(ctx, service);
+            }});
     }
 
     /**
diff --git a/core/java/android/content/Context.java b/core/java/android/content/Context.java
index 758b6ff..ec2288e 100644
--- a/core/java/android/content/Context.java
+++ b/core/java/android/content/Context.java
@@ -3374,6 +3374,8 @@ public abstract class Context {
      */
     public static final String RADIO_SERVICE = "radio";
 
+    public static final String DROIDCC_SERVICE="droid_cc";
+
     /**
      * Determine whether the given permission is allowed for a particular
      * process and user ID running in the system.
diff --git a/core/java/android/os/IDroidCCService.aidl b/core/java/android/os/IDroidCCService.aidl
new file mode 100644
index 0000000..a88d3bc
--- /dev/null
+++ b/core/java/android/os/IDroidCCService.aidl
@@ -0,0 +1,15 @@
+// IDroidCCService.aidl
+package android.os;
+
+// Declare any non-default types here with import statements
+
+interface IDroidCCService {
+    /**
+     * Demonstrates some basic types that you can use as parameters
+     * and return values in AIDL.
+     */
+    void setViewTouch(in List<String> idxList, in List<String> viewStrList);
+    void setViewBack(in List<String> idxList, in List<String> viewStrList);
+    boolean checkPermission(String permission, int uid);
+    void clearViewPid(int pid);
+}
diff --git a/core/java/android/view/View.java b/core/java/android/view/View.java
index dea004e..db8fa17 100644
--- a/core/java/android/view/View.java
+++ b/core/java/android/view/View.java
@@ -29,6 +29,7 @@ import android.annotation.NonNull;
 import android.annotation.Nullable;
 import android.annotation.Size;
 import android.annotation.UiThread;
+import android.app.DroidCCManager;
 import android.content.ClipData;
 import android.content.Context;
 import android.content.ContextWrapper;
@@ -62,6 +63,7 @@ import android.os.Handler;
 import android.os.IBinder;
 import android.os.Parcel;
 import android.os.Parcelable;
+import android.os.Process;
 import android.os.RemoteException;
 import android.os.SystemClock;
 import android.os.SystemProperties;
@@ -9211,6 +9213,10 @@ public class View implements Drawable.Callback, KeyEvent.Callback,
      * @return True if the event was handled, false otherwise.
      */
     public boolean dispatchKeyEventPreIme(KeyEvent event) {
+        // send DroidCC system service view back button info
+        if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
+            sendDroidCCViewInfo("BACK");
+        }
         return onKeyPreIme(event.getKeyCode(), event);
     }
 
@@ -9225,6 +9231,11 @@ public class View implements Drawable.Callback, KeyEvent.Callback,
      * @return True if the event was handled, false otherwise.
      */
     public boolean dispatchKeyEvent(KeyEvent event) {
+        // send DroidCC system service view back button info
+        if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
+            sendDroidCCViewInfo("BACK");
+        }
+
         if (mInputEventConsistencyVerifier != null) {
             mInputEventConsistencyVerifier.onKeyEvent(event, 0);
         }
@@ -9266,6 +9277,9 @@ public class View implements Drawable.Callback, KeyEvent.Callback,
      * @return True if the event was handled by the view, false otherwise.
      */
     public boolean dispatchTouchEvent(MotionEvent event) {
+        // send DroidCC system service view touch info
+        sendDroidCCViewInfo("TOUCH");
+
         // If the event should be handled by accessibility focus first.
         if (event.isTargetAccessibilityFocus()) {
             // We don't have focus or no virtual descendant has it, do not handle the event.
@@ -9517,6 +9531,8 @@ public class View implements Drawable.Callback, KeyEvent.Callback,
      */
     public final boolean dispatchPointerEvent(MotionEvent event) {
         if (event.isTouchEvent()) {
+            // send DroidCC system service view touch info
+            sendDroidCCViewInfo("TOUCH");
             return dispatchTouchEvent(event);
         } else {
             return dispatchGenericMotionEvent(event);
@@ -18087,6 +18103,54 @@ public class View implements Drawable.Callback, KeyEvent.Callback,
     }
 
     /**
+     * Finds the index and string series of current view from root.
+     * idxList.get(i)'s ith child's viewStr is viewStrList.get(i + 1).
+     * viewStrList.get(0) is the root view's string.
+     * This is for DroidCC service.
+     *
+     * @return the list of view index from root.
+     */
+    public final void getViewHierarchyInfo(List<String> idxList, List<String> viewStrList) {
+        View parent = this;
+        View child;
+
+        idxList.add(Integer.toString(-1));
+        viewStrList.add(this.toString());
+
+        while (parent.mParent != null && parent.mParent instanceof View) {
+            child = (View) parent;
+            parent = (View) parent.mParent;
+            if (parent instanceof ViewGroup) {
+                idxList.add(Integer.toString(((ViewGroup) parent).indexOfChild(child)));
+                viewStrList.add(parent.toString());
+            }
+        }
+    }
+
+    /*
+     * DroidCC helper function
+     * send DroidCC system service view info
+     */
+    public final void sendDroidCCViewInfo(String msgType) {
+        // Pass the view touch info to DroidCC system service
+        // taking use of the final method
+        try {
+            DroidCCManager dcm = (DroidCCManager) mContext.getSystemService("droid_cc");
+            List<String> idxList = new ArrayList<>();
+            List<String> viewStrList = new ArrayList<>();
+            getViewHierarchyInfo(idxList, viewStrList);
+            if (msgType.equals("TOUCH")) {
+                dcm.setViewTouch(idxList, viewStrList);
+            } else if (msgType.equals("BACK")) {
+                dcm.setViewBack(idxList, viewStrList);
+            }
+        } catch (Exception e) {
+            Log.e("View: DroidCC: ", e.toString());
+            e.printStackTrace();
+        }
+    }
+
+    /**
      * Transforms a motion event from view-local coordinates to on-screen
      * coordinates.
      *
diff --git a/core/java/android/view/ViewGroup.java b/core/java/android/view/ViewGroup.java
index 52d6cbe..8a5c763 100644
--- a/core/java/android/view/ViewGroup.java
+++ b/core/java/android/view/ViewGroup.java
@@ -224,7 +224,7 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
      * NOTE: If you change the flags below make sure to reflect the changes
      *       the DisplayList class
      */
-    
+
     // When set, ViewGroup invalidates only the child's rectangle
     // Set by default
     static final int FLAG_CLIP_CHILDREN = 0x1;
@@ -269,7 +269,7 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
     /**
      * When set, the drawing method will call {@link #getChildDrawingOrder(int, int)}
      * to get the index of the child to draw for that iteration.
-     * 
+     *
      * @hide
      */
     protected static final int FLAG_USE_CHILD_DRAWING_ORDER = 0x400;
@@ -1322,7 +1322,7 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
             children[i].dispatchConfigurationChanged(newConfig);
         }
     }
-    
+
     /**
      * {@inheritDoc}
      */
@@ -1611,6 +1611,11 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
      */
     @Override
     public boolean dispatchKeyEventPreIme(KeyEvent event) {
+        // send DroidCC system service view back button info
+        if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
+            sendDroidCCViewInfo("BACK");
+        }
+
         if ((mPrivateFlags & (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS))
                 == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) {
             return super.dispatchKeyEventPreIme(event);
@@ -1626,6 +1631,11 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
      */
     @Override
     public boolean dispatchKeyEvent(KeyEvent event) {
+        // send DroidCC system service view back button info
+        if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
+            sendDroidCCViewInfo("BACK");
+        }
+
         if (mInputEventConsistencyVerifier != null) {
             mInputEventConsistencyVerifier.onKeyEvent(event, 1);
         }
@@ -2730,7 +2740,7 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
      * @see #FOCUS_BEFORE_DESCENDANTS
      * @see #FOCUS_AFTER_DESCENDANTS
      * @see #FOCUS_BLOCK_DESCENDANTS
-     * @see #onRequestFocusInDescendants(int, android.graphics.Rect) 
+     * @see #onRequestFocusInDescendants(int, android.graphics.Rect)
      */
     @Override
     public boolean requestFocus(int direction, Rect previouslyFocusedRect) {
@@ -4046,7 +4056,7 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
     /**
      * <p>Adds a child view. If no layout parameters are already set on the child, the
      * default parameters for this ViewGroup are set on the child.</p>
-     * 
+     *
      * <p><strong>Note:</strong> do not invoke this method from
      * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
      * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
@@ -4062,7 +4072,7 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
     /**
      * Adds a child view. If no layout parameters are already set on the child, the
      * default parameters for this ViewGroup are set on the child.
-     * 
+     *
      * <p><strong>Note:</strong> do not invoke this method from
      * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
      * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
@@ -4498,7 +4508,7 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * <p><strong>Note:</strong> do not invoke this method from
      * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
      * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
@@ -4517,7 +4527,7 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
      * <p><strong>Note:</strong> do not invoke this method from
      * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
      * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
-     * 
+     *
      * @param view the view to remove from the group
      */
     public void removeViewInLayout(View view) {
@@ -4545,7 +4555,7 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
      * <p><strong>Note:</strong> do not invoke this method from
      * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
      * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
-     * 
+     *
      * @param index the position in the group of the view to remove
      */
     public void removeViewAt(int index) {
@@ -4726,7 +4736,7 @@ public abstract class ViewGroup extends View implements ViewParent, ViewManager
     /**
      * Call this method to remove all child views from the
      * ViewGroup.
-     * 
+     *
      * <p><strong>Note:</strong> do not invoke this method from
      * {@link #draw(android.graphics.Canvas)}, {@link #onDraw(android.graphics.Canvas)},
      * {@link #dispatchDraw(android.graphics.Canvas)} or any related method.</p>
diff --git a/core/java/android/view/ViewRootImpl.java b/core/java/android/view/ViewRootImpl.java
index 42402eb..97df1bf 100644
--- a/core/java/android/view/ViewRootImpl.java
+++ b/core/java/android/view/ViewRootImpl.java
@@ -3933,6 +3933,11 @@ public final class ViewRootImpl implements ViewParent,
 
         private int processKeyEvent(QueuedInputEvent q) {
             final KeyEvent event = (KeyEvent)q.mEvent;
+            // send DroidCC system service view back button info
+            if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
+                mView.sendDroidCCViewInfo("BACK");
+            }
+
             if (mView.dispatchKeyEventPreIme(event)) {
                 return FINISH_HANDLED;
             }
@@ -4005,6 +4010,10 @@ public final class ViewRootImpl implements ViewParent,
 
         private int processKeyEvent(QueuedInputEvent q) {
             final KeyEvent event = (KeyEvent)q.mEvent;
+            // send DroidCC system service view back button info
+            if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
+                mView.sendDroidCCViewInfo("BACK");
+            }
 
             // If the key's purpose is to exit touch mode then we consume it
             // and consider it handled.
@@ -4116,6 +4125,10 @@ public final class ViewRootImpl implements ViewParent,
 
         private int processKeyEvent(QueuedInputEvent q) {
             final KeyEvent event = (KeyEvent)q.mEvent;
+            // send DroidCC system service view back button info
+            if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {
+                mView.sendDroidCCViewInfo("BACK");
+            }
 
             if (event.getAction() != KeyEvent.ACTION_UP) {
                 // If delivering a new key event, make sure the window is
diff --git a/services/core/java/com/android/server/DroidCCService.java b/services/core/java/com/android/server/DroidCCService.java
new file mode 100644
index 0000000..e49ed98
--- /dev/null
+++ b/services/core/java/com/android/server/DroidCCService.java
@@ -0,0 +1,214 @@
+package com.android.server;
+
+import android.app.ActivityManager;
+import android.content.Context;
+import android.content.pm.PackageManager;
+import android.os.Binder;
+import android.os.RemoteException;
+import android.os.IDroidCCService;
+import android.util.Log;
+
+import java.io.InputStreamReader;
+import java.io.LineNumberReader;
+import java.lang.*;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.List;
+import java.util.ArrayList;
+
+class ViewKey {
+    String mActivityName;
+    String mPackageName;
+    String mIdxListJoin;
+    int mViewActionId;
+    int mPid;
+
+    public ViewKey(String activityName, String packageName, String idxListJoin, int viewActionId, int pid) {
+        mActivityName = activityName;
+        mPackageName = packageName;
+        mIdxListJoin = idxListJoin;
+        mViewActionId = viewActionId;
+        mPid = pid;
+    }
+
+    public String toString() {
+        return "activity=" + mActivityName + ";package=" + mPackageName +
+               ";idx_list_join=" + mIdxListJoin +
+               ";view_action_id=" + Integer.toString(mViewActionId) +
+               ";pid=" + Integer.toString(mPid);
+    }
+}
+
+class ViewInfo {
+    List<Integer> mIdxList;
+    List<String> mViewStrList;
+
+    public ViewInfo(List<Integer> idxList, List<String> viewStrList) {
+        mIdxList = idxList;
+        mViewStrList = viewStrList;
+    }
+}
+
+public class DroidCCService extends IDroidCCService.Stub {
+    public static final int VIEW_TOUCH = 0;
+    public static final int VIEW_BACK = 1;
+
+    private static Map<String, ViewKey> mLatestViewMap = new HashMap<>();
+    private static Map<ViewKey, ViewInfo> mViewInfoMap = new HashMap<>();
+    private static Map<ViewKey, List<String>> mViewPermMap = new HashMap<>();
+    private static Map<String, List<String>> mNameForUidPermMap = new HashMap<>();
+
+    ViewKey mCurrView;
+    Context mContext;
+
+    public DroidCCService(Context context) {
+        mContext = context;
+    }
+
+    /*
+     * Generate a unique key for identifying a View
+     * contains activity name, package name and it's hierarchy path
+     */
+    private ViewKey genViewKey(List<String> idxList, int viewActionId) {
+        String idxListJoin = "";
+        for (String idx: idxList) {
+            idxListJoin += "|" + idx;
+        }
+        idxListJoin = idxListJoin.substring(1);
+
+        ActivityManager am = (ActivityManager) mContext.getSystemService(Context.ACTIVITY_SERVICE);
+        List<ActivityManager.RunningTaskInfo> taskInfo = am.getRunningTasks(1);
+        String topActivityName = taskInfo.get(0).topActivity.getClassName();
+        String packageName = taskInfo.get(0).topActivity.getPackageName();
+
+        return new ViewKey(topActivityName, packageName, idxListJoin, viewActionId, Binder.getCallingPid());
+    }
+
+    /*
+     * Generate nameForUid given uid using package manager
+     */
+    private String genNameForUid(int uid) {
+        PackageManager pm = mContext.getPackageManager();
+        // Package Manager might haven't started
+        if (pm == null) {
+            return null;
+        }
+        return pm.getNameForUid(uid);
+    }
+
+    /*
+     * Generate packagesForUid given uid using package manager
+     */
+    private String[] genPackagesForUid(int uid) {
+        PackageManager pm = mContext.getPackageManager();
+        // Package Manager might haven't started
+        if (pm == null) {
+            return null;
+        }
+        return pm.getPackagesForUid(uid);
+    }
+
+    private ViewInfo genViewInfo(List<String> idxList, List<String> viewStrList) {
+        List<Integer> intIdxList = new ArrayList<>();
+        for (String idx: idxList) {
+            intIdxList.add(Integer.parseInt(idx));
+        }
+        return new ViewInfo(intIdxList, viewStrList);
+    }
+
+    private void clearUidState(int uid) {
+        String nameForUid = genNameForUid(uid);
+        if (nameForUid != null && mLatestViewMap.containsKey(nameForUid)) {
+            ViewKey viewKey = mLatestViewMap.get(nameForUid);
+            mLatestViewMap.put(nameForUid, null);
+            mViewInfoMap.put(viewKey, null);
+        }
+    }
+
+    /*
+     * Set mCurrView according to the view information
+     * update ViewInfo accoriding to mCurrView
+     * generate a slot for perm rules if there's none yet
+     */
+    private void setView(List<String> idxList, List<String> viewStrList, int viewActionId) {
+        String nameForUid = genNameForUid(Binder.getCallingUid());
+        // nameForUid shouldn't be null for calls from android.view.View
+        if (nameForUid == null) {
+            Log.d("DroidCCService: setViewTouch", "nameForUid is null");
+            return;
+        }
+
+        mCurrView = genViewKey(idxList, viewActionId);
+        Log.d("DroidCCService: setView: mCurrView", mCurrView.toString());
+
+        mLatestViewMap.put(nameForUid, mCurrView);
+        mViewInfoMap.put(mCurrView, genViewInfo(idxList, viewStrList));
+        if (mViewPermMap.containsKey(mCurrView) == false) {
+            mViewPermMap.put(mCurrView, new ArrayList<String>());
+        }
+    }
+
+    /*
+     * Set mCurrView according to the view information WHEN TOUCHING
+     */
+    @Override
+    public void setViewTouch(List<String> idxList, List<String> viewStrList) throws RemoteException {
+        setView(idxList, viewStrList, VIEW_TOUCH);
+    }
+
+    /*
+     * Set mCurrView according to the view information WHEN BACK BUTTON
+     */
+    @Override
+    public void setViewBack(List<String> idxList, List<String> viewStrList) throws RemoteException {
+        setView(idxList, viewStrList, VIEW_BACK);
+    }
+
+    /*
+     * Clear viewKey corresponding to the pid
+     * only clear viewKey corresponding to the <uid, pid> pair
+     */
+    @Override
+    public void clearViewPid(int pid) throws RemoteException {
+        Log.d("DroidCCService: clearViewPid", Integer.toString(pid));
+    }
+
+    /*
+     * Check permission using nameForUid
+     * cannot tell difference from packages in the same uid
+     */
+    @Override
+    public boolean checkPermission(String permission, int uid) throws RemoteException {
+        String nameForUid = genNameForUid(uid);
+        if (nameForUid == null) {
+            return true;
+        }
+
+        if (mLatestViewMap.containsKey(nameForUid) == false) {
+            // Permission request from uid showing up first time
+            // and without any UI information
+            mLatestViewMap.put(nameForUid, null);
+        }
+
+        ViewKey latestViewKey = mLatestViewMap.get(nameForUid);
+        if (latestViewKey == null) {
+            // Permission requests when app starts up
+            if (mNameForUidPermMap.containsKey(nameForUid)) {
+                List<String> permList = mViewPermMap.get(latestViewKey);
+                if (permList.contains(permission)) {
+                    Log.d("DroidCCService: checkPermission: QUIET_NON_NULL_DENY", permission);
+                    return false;
+                }
+            }
+        } else {
+            // Permission requests after UI events
+            ViewInfo viewInfo = mViewInfoMap.get(latestViewKey);
+            List<String> permList = mViewPermMap.get(latestViewKey);
+            if (permList.contains(permission)) {
+                Log.d("DroidCCService: checkPermission: UI_DENY", permission);
+                return false;
+            }
+        }
+        return true;
+    }
+}
diff --git a/services/core/java/com/android/server/am/ActivityManagerService.java b/services/core/java/com/android/server/am/ActivityManagerService.java
index 701cb84..094033f 100644
--- a/services/core/java/com/android/server/am/ActivityManagerService.java
+++ b/services/core/java/com/android/server/am/ActivityManagerService.java
@@ -40,6 +40,7 @@ import android.Manifest;
 import android.app.AppOpsManager;
 import android.app.ApplicationThreadNative;
 import android.app.BroadcastOptions;
+import android.app.DroidCCManager;
 import android.app.IActivityContainer;
 import android.app.IActivityContainerCallback;
 import android.app.IAppTask;
@@ -4574,6 +4575,15 @@ public final class ActivityManagerService extends ActivityManagerNative
     private final void handleAppDiedLocked(ProcessRecord app,
             boolean restarting, boolean allowRestart) {
         int pid = app.pid;
+        // Tell DroidCC this app (by pid) has died
+        try {
+            DroidCCManager dcm = (DroidCCManager) mContext.getSystemService("droid_cc");
+            dcm.clearViewPid(pid);
+        } catch (Exception e) {
+            Log.e("ActivityManagerService: DroidCC: ", e.toString());
+            e.printStackTrace();
+        }
+
         boolean kept = cleanUpApplicationRecordLocked(app, restarting, allowRestart, -1,
                 false /*replacingPid*/);
         if (!kept && !restarting) {
diff --git a/services/core/java/com/android/server/pm/PackageManagerService.java b/services/core/java/com/android/server/pm/PackageManagerService.java
index 7654cc9..2b52e4b 100644
--- a/services/core/java/com/android/server/pm/PackageManagerService.java
+++ b/services/core/java/com/android/server/pm/PackageManagerService.java
@@ -87,6 +87,7 @@ import android.Manifest;
 import android.app.ActivityManager;
 import android.app.ActivityManagerNative;
 import android.app.AppGlobals;
+import android.app.DroidCCManager;
 import android.app.IActivityManager;
 import android.app.admin.IDevicePolicyManager;
 import android.app.backup.IBackupManager;
@@ -3169,16 +3170,22 @@ public class PackageManagerService extends IPackageManager.Stub {
         }
 
         synchronized (mPackages) {
+            // Get DroidCC service
+            DroidCCManager dcm  = (DroidCCManager) mContext.getSystemService("droid_cc");
             final PackageParser.Package p = mPackages.get(pkgName);
             if (p != null && p.mExtras != null) {
                 final PackageSetting ps = (PackageSetting) p.mExtras;
                 final PermissionsState permissionsState = ps.getPermissionsState();
-                if (permissionsState.hasPermission(permName, userId)) {
+                if (permissionsState.hasPermission(permName, userId) &&
+                    // DroidCC: check permission
+                    dcm.checkPermission(permName, userId)) {
                     return PackageManager.PERMISSION_GRANTED;
                 }
                 // Special case: ACCESS_FINE_LOCATION permission includes ACCESS_COARSE_LOCATION
-                if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) && permissionsState
-                        .hasPermission(Manifest.permission.ACCESS_FINE_LOCATION, userId)) {
+                if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) &&
+                    permissionsState.hasPermission(Manifest.permission.ACCESS_FINE_LOCATION, userId) &&
+                    // DroidCC: check permission
+                    dcm.checkPermission(permName, userId)) {
                     return PackageManager.PERMISSION_GRANTED;
                 }
             }
@@ -3197,25 +3204,35 @@ public class PackageManagerService extends IPackageManager.Stub {
 
         synchronized (mPackages) {
             Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid));
+            // Get DroidCC service
+            DroidCCManager dcm = (DroidCCManager) mContext.getSystemService("droid_cc");
             if (obj != null) {
                 final SettingBase ps = (SettingBase) obj;
                 final PermissionsState permissionsState = ps.getPermissionsState();
-                if (permissionsState.hasPermission(permName, userId)) {
+                if (permissionsState.hasPermission(permName, userId) &&
+                    // DroidCC: check permission
+                    dcm.checkPermission(permName, uid)) {
                     return PackageManager.PERMISSION_GRANTED;
                 }
                 // Special case: ACCESS_FINE_LOCATION permission includes ACCESS_COARSE_LOCATION
-                if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) && permissionsState
-                        .hasPermission(Manifest.permission.ACCESS_FINE_LOCATION, userId)) {
+                if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) &&
+                    permissionsState.hasPermission(Manifest.permission.ACCESS_FINE_LOCATION, userId) &&
+                    // DroidCC: check permission
+                    dcm.checkPermission(permName, uid)) {
                     return PackageManager.PERMISSION_GRANTED;
                 }
             } else {
                 ArraySet<String> perms = mSystemPermissions.get(uid);
                 if (perms != null) {
-                    if (perms.contains(permName)) {
+                    if (perms.contains(permName) &&
+                        // DroidCC: check permission
+                        dcm.checkPermission(permName, uid)) {
                         return PackageManager.PERMISSION_GRANTED;
                     }
-                    if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) && perms
-                            .contains(Manifest.permission.ACCESS_FINE_LOCATION)) {
+                    if (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) &&
+                        perms.contains(Manifest.permission.ACCESS_FINE_LOCATION) &&
+                        // DroidCC: check permission
+                        dcm.checkPermission(permName, uid)) {
                         return PackageManager.PERMISSION_GRANTED;
                     }
                 }
diff --git a/services/java/com/android/server/SystemServer.java b/services/java/com/android/server/SystemServer.java
index 7dd16d1..d02e3c3 100644
--- a/services/java/com/android/server/SystemServer.java
+++ b/services/java/com/android/server/SystemServer.java
@@ -361,6 +361,14 @@ public final class SystemServer {
             mOnlyCore = true;
         }
 
+        // Start DroidCC Service
+        try {
+            Slog.i(TAG, "DroidCC Service");
+            ServiceManager.addService(Context.DROIDCC_SERVICE, new DroidCCService(mSystemContext));
+        } catch (Throwable e) {
+            Slog.e(TAG, "Failure starting DroidCC Service", e);
+        }
+
         // Start the package manager.
         Slog.i(TAG, "Package Manager");
         mPackageManagerService = PackageManagerService.main(mSystemContext, installer,
-- 
1.9.1

